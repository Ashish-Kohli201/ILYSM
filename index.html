<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon City Drive</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; }

        /* --- UI LAYER --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffcc;
            border-radius: 50%; /* Circular Map */
            overflow: hidden;
            z-index: 10;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Speedometer */
        #speedometer {
            position: absolute;
            top: 20px;
            left: 190px; /* Next to minimap */
            color: #fff;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            font-style: italic;
        }

        /* Controls */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        /* Exit Button - Fixed for Mobile */
        #exit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(to bottom, #ff3333, #aa0000);
            color: white;
            border: 2px solid white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            text-transform: uppercase;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 9999; /* Ensure it's on top */
            -webkit-tap-highlight-color: transparent;
        }
        #exit-btn:active { transform: scale(0.95); }

        /* Start Overlay */
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid #00ffcc;
            pointer-events: auto;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div id="minimap-container">
            <canvas id="minimap-canvas"></canvas>
        </div>
        <div id="speedometer">0 KM/H</div>
        <button id="exit-btn" onclick="closeGame()">EXIT CITY</button>
        <div id="joystick-zone"></div>
        
        <div id="overlay">
            <h1>NEON CITY</h1>
            <p>Drag Joystick to Drive.</p>
            <p>Explore the city.</p>
            <button onclick="startGame()" style="padding: 10px 30px; font-size: 18px; cursor: pointer; background: #00ffcc; border: none; font-weight: bold;">START ENGINE</button>
        </div>
    </div>
</div>

<script>
    // --- 1. GLOBAL VARIABLES ---
    const container = document.getElementById('game-container');
    const minimapCanvas = document.getElementById('minimap-canvas');
    let scene, camera, renderer;
    let minimapCtx;
    let car, wheels = [];
    let buildings = []; // Store building positions for minimap
    let speed = 0;
    let steering = 0;
    
    // Physics Config
    const maxSpeed = 3.0;
    const acceleration = 0.08;
    const friction = 0.97;
    const turnSpeed = 0.06;

    // Audio
    let audioCtx, engineOsc;
    let gameActive = false;

    // --- 2. TEXTURE GENERATORS (Procedural) ---
    function createBuildingTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        // Base color (dark blue-grey)
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0,0,64,128);
        // Windows (lit and unlit)
        for(let y=10; y<120; y+=10) {
            for(let x=5; x<60; x+=10) {
                if(Math.random() > 0.3) {
                    ctx.fillStyle = Math.random() > 0.8 ? '#ffffaa' : '#444455'; // Some lights on
                    ctx.fillRect(x, y, 6, 8);
                }
            }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
    }

    // --- 3. INIT ---
    function init() {
        // Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Day/Dusk Sky
        scene.fog = new THREE.Fog(0x87CEEB, 200, 600); // Reduced fog, pushed far back

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, -20);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const sun = new THREE.DirectionalLight(0xffffff, 0.9);
        sun.position.set(100, 200, 100);
        sun.castShadow = true;
        sun.shadow.camera.left = -200;
        sun.shadow.camera.right = 200;
        sun.shadow.camera.top = 200;
        sun.shadow.camera.bottom = -200;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // --- WORLD GENERATION ---
        createCity();
        createCar();

        // --- CONTROLS ---
        setupJoystick();

        // --- MINIMAP SETUP ---
        minimapCtx = minimapCanvas.getContext('2d');

        window.addEventListener('resize', onWindowResize, false);
    }

    function createCity() {
        // 1. Ground (Asphalt)
        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 2. City Grid Generator
        const blockSize = 80;
        const streetWidth = 20;
        const citySize = 10; // 10x10 blocks (Massive)
        
        const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
        // Move pivot to bottom
        buildingGeo.translate(0, 0.5, 0); 
        const winTex = createBuildingTexture();
        const buildingMat = new THREE.MeshStandardMaterial({ map: winTex });
        const parkMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });

        // Loop to create blocks
        for(let x = -citySize; x <= citySize; x++) {
            for(let z = -citySize; z <= citySize; z++) {
                
                // Keep center clear for start area
                if(Math.abs(x) < 2 && Math.abs(z) < 2) continue;

                const centerX = x * blockSize;
                const centerZ = z * blockSize;

                // Randomly decide: Building Block or Park?
                const isPark = Math.random() > 0.85;

                if (isPark) {
                    // Create Park (Low green block)
                    const park = new THREE.Mesh(buildingGeo, parkMat);
                    park.position.set(centerX, 0, centerZ);
                    park.scale.set(blockSize - streetWidth, 0.5, blockSize - streetWidth);
                    scene.add(park);
                    // Add to minimap list
                    buildings.push({x: centerX, z: centerZ, w: blockSize-streetWidth, h: blockSize-streetWidth, type: 'park'});
                } else {
                    // Create Cluster of Buildings in this block
                    const subdiv = 2; // 2x2 buildings per block
                    const subSize = (blockSize - streetWidth) / subdiv;
                    
                    for(let sx=0; sx<subdiv; sx++) {
                        for(let sz=0; sz<subdiv; sz++) {
                            // Random Height
                            const height = 20 + Math.random() * 80;
                            const bMesh = new THREE.Mesh(buildingGeo, buildingMat);
                            
                            const posX = centerX - ((blockSize-streetWidth)/2) + (sx * subSize) + subSize/2;
                            const posZ = centerZ - ((blockSize-streetWidth)/2) + (sz * subSize) + subSize/2;

                            bMesh.position.set(posX, 0, posZ);
                            // Scale: width, height, depth (leave small gap between buildings)
                            bMesh.scale.set(subSize - 2, height, subSize - 2);
                            bMesh.castShadow = true;
                            bMesh.receiveShadow = true;
                            scene.add(bMesh);

                            buildings.push({x: posX, z: posZ, w: subSize-2, h: subSize-2, type: 'building'});
                        }
                    }
                }
            }
        }
    }

    function createCar() {
        car = new THREE.Group();

        // Car Body (Sports shape)
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0055, metalness: 0.7, roughness: 0.2 });
        const glassMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });

        // Main chassis
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 4.5), bodyMat);
        chassis.position.y = 0.6;
        chassis.castShadow = true;
        car.add(chassis);

        // Cabin
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 2.5), glassMat);
        cabin.position.set(0, 1.1, -0.5);
        car.add(cabin);
        
        // Hood scoop
        const scoop = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 1), bodyMat);
        scoop.position.set(0, 0.9, 1.5);
        car.add(scoop);

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 24);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const positions = [ [-1.1, 1.5], [1.1, 1.5], [-1.1, -1.5], [1.1, -1.5] ];
        
        positions.forEach(p => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(p[0], 0.4, p[1]);
            w.castShadow = true;
            car.add(w);
            wheels.push(w);
        });

        // Headlights (Spotlights)
        const leftLight = new THREE.SpotLight(0xffffff, 2, 60, 0.6, 0.5, 1);
        leftLight.position.set(-0.8, 1, 2);
        leftLight.target.position.set(-0.8, 0.5, 20);
        car.add(leftLight);
        car.add(leftLight.target);
        
        const rightLight = new THREE.SpotLight(0xffffff, 2, 60, 0.6, 0.5, 1);
        rightLight.position.set(0.8, 1, 2);
        rightLight.target.position.set(0.8, 0.5, 20);
        car.add(rightLight);
        car.add(rightLight.target);

        scene.add(car);
    }

    function setupJoystick() {
        const manager = nipplejs.create({
            zone: document.getElementById('joystick-zone'),
            mode: 'static',
            position: { left: '50%', bottom: '50%' },
            color: 'white'
        });

        manager.on('move', (evt, data) => {
            const angle = data.angle.radian;
            // Up pushes Z forward (in 3D logic)
            const forward = Math.sin(angle); 
            const turn = Math.cos(angle);
            
            if(forward > 0) speed += acceleration * forward;
            else speed += acceleration * forward; // Reverse

            steering = -turn * turnSpeed;
        });

        manager.on('end', () => { steering = 0; });
    }

    function updateMinimap() {
        // Clear minimap
        minimapCtx.fillStyle = '#000';
        minimapCtx.fillRect(0, 0, 150, 150);

        // Map Scale (World Units to Pixel Units)
        const mapScale = 0.5;
        const centerX = 75; // Canvas center
        const centerY = 75;

        // Save context to rotate entire map around player
        minimapCtx.save();
        minimapCtx.translate(centerX, centerY);
        minimapCtx.rotate(car.rotation.y); // Rotate map opposite to car
        minimapCtx.translate(-centerX, -centerY);

        // Draw Buildings relative to car
        buildings.forEach(b => {
            // Calculate relative position
            const relX = (b.x - car.position.x) * mapScale;
            const relZ = (car.position.z - b.z) * mapScale; // Canvas Y is inverted relative to 3D Z

            // Only draw if within range
            if(Math.abs(relX) < 80 && Math.abs(relZ) < 80) {
                minimapCtx.fillStyle = b.type === 'park' ? '#00ff00' : '#555';
                minimapCtx.fillRect(centerX - relX - (b.w*mapScale)/2, centerY - relZ - (b.h*mapScale)/2, b.w*mapScale, b.h*mapScale);
            }
        });

        minimapCtx.restore();

        // Draw Player (Fixed in center)
        minimapCtx.fillStyle = '#00ffcc';
        minimapCtx.beginPath();
        minimapCtx.arc(centerX, centerY, 3, 0, Math.PI*2);
        minimapCtx.fill();
        
        // Direction Arrow
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.beginPath();
        minimapCtx.moveTo(centerX, centerY - 5);
        minimapCtx.lineTo(centerX - 3, centerY + 3);
        minimapCtx.lineTo(centerX + 3, centerY + 3);
        minimapCtx.closePath();
        minimapCtx.stroke();
    }

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        
        // Init Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        engineOsc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        engineOsc.connect(gain);
        gain.connect(audioCtx.destination);
        engineOsc.frequency.value = 50;
        gain.gain.value = 0.1;
        engineOsc.start();
        
        gameActive = true;
        animate();
    }

    function animate() {
        if(!gameActive) return;
        requestAnimationFrame(animate);

        // Physics
        speed *= friction;
        car.rotation.y += steering * Math.sign(speed);
        car.position.x += Math.sin(car.rotation.y) * speed;
        car.position.z += Math.cos(car.rotation.y) * speed;

        // Wheels animation
        wheels.forEach(w => w.rotation.x -= speed * 0.5);

        // Camera Follow (Smooth)
        const relOffset = new THREE.Vector3(0, 8, -15);
        const camOffset = relOffset.applyMatrix4(car.matrixWorld);
        camera.position.lerp(camOffset, 0.1);
        camera.lookAt(car.position.x, car.position.y, car.position.z);

        // Update Audio Pitch
        if(audioCtx) {
            engineOsc.frequency.setValueAtTime(50 + Math.abs(speed)*100, audioCtx.currentTime);
        }

        // Update UI
        document.getElementById('speedometer').innerText = Math.floor(Math.abs(speed)*20) + " KM/H";
        updateMinimap();

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function closeGame() {
        if(audioCtx) audioCtx.close();
        document.getElementById('game-container').innerHTML = "<h1 style='color:white; text-align:center; margin-top:50px;'>GAME CLOSED</h1>";
    }

    init();

</script>
</body>
</html>
